// @ts-ignore -- doesn't provide types
import { lch } from "d3-color";
// @ts-ignore -- doesn't provide types
import tailwinduiColors from "@tailwindcss/ui/colors";
// @ts-ignore -- doesn't provide types
import defaultConfig from "tailwindcss/defaultConfig";

// @ts-ignore -- doesn't provide types
import { differenceEuclideanLab, differenceCiede2000 } from "d3-color-difference";

import { forEach, forEachRight, tail, zip } from "utils";

// @ts-ignore -- doesn't provide types
import basic from "color-namer/lib/colors/basic";
// @ts-ignore -- doesn't provide types
import html from "color-namer/lib/colors/html";
// @ts-ignore -- doesn't provide types
import ntc from "color-namer/lib/colors/ntc";
// @ts-ignore -- doesn't provide types
import pantone from "color-namer/lib/colors/pantone";
// @ts-ignore -- doesn't provide types
import roygbiv from "color-namer/lib/colors/roygbiv";
// @ts-ignore -- doesn't provide types
import x11 from "color-namer/lib/colors/x11";

export type Palette = Record<string | number, string>;

const lists = {
	basic,
	html,
	ntc,
	pantone,
	roygbiv,
	x11,
};

const { theme: defaultTheme } = defaultConfig;

const defaultTailwindColors = defaultTheme.colors;

export const paletteGroups = {
	defaultTailwindColors,
	tailwinduiColors,
};

const clamp = (num: number, min: number, max: number): number => {
	return num <= min ? min : num >= max ? max : num;
};

const lchClamped = (l: number, c: number, h: number) => {
	return lch(clamp(l, 0, 100), clamp(c, 0, 132), clamp(h % 360, 0, 360));
};

// eslint-disable-next-line max-len,  @typescript-eslint/no-explicit-any
export const giveColorNames = (color: string, options: Partial<{distance: string, pick: string[], omit: string[]}> = {}): any => {
	const useDeltaE = String(options.distance).toLowerCase() === "deltae";
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const results: any = {};
	let key: keyof typeof lists;
	// eslint-disable-next-line no-restricted-syntax
	for (key in lists) {
		if (options.pick && options.pick.indexOf(key) === -1) {
			// eslint-disable-next-line no-continue
			continue;
		}
		if (options.omit && options.omit.indexOf(key) !== -1) {
			// eslint-disable-next-line no-continue
			continue;
		}
		results[key] = lists[key]
			.map((name: { distance: number; hex: string | number; }) => {
				// eslint-disable-next-line max-len, no-param-reassign
				name.distance = useDeltaE ? differenceCiede2000(color, name.hex) : differenceEuclideanLab(color, name.hex);
				return name;
			})
			.sort((a: { distance: number; }, b: { distance: number; }) => a.distance - b.distance);
	}
	return results;
};

// eslint-disable-next-line max-len
export const nameColor = (color: string, options: Partial<{ distance: string, pick: string[], omit: string[] }> = {}): string => {
	const colorNames = giveColorNames(color, options);

	// @ts-ignore
	// eslint-disable-next-line max-len
	const [_distance, bestColorName] = Object.values(colorNames).reduce(([winningDistance, winningColorName]: [number, string], [thisColor]: { name: string, distance: number }) => {
		if (thisColor.distance < winningDistance) {
			return [thisColor.distance, thisColor.name];
		}
		return [winningDistance, winningColorName];
	}, [Number.POSITIVE_INFINITY, "unknown"]);

	return bestColorName.toLowerCase().replace(/[\W]/g, "");
};

export const getNearestPalette = (color: string): any => {
	// TODO: implement
	const asLch = lch(color);

	const differences = Object.entries(paletteGroups).map(([paletteGroupName, paletteGroup]) => Object.entries(paletteGroup).map(([paletteName, palette]: [string, string | any]) =>
		// @ts-ignore
		[paletteName, Object.entries(palette).reduce(([winningDifference, winningShade]: [number, string], [shade, value]) => {
			const valueLch = lch(value);

			const cDifference = Math.abs(valueLch.c - asLch.c);
			let hDifference = Math.abs(valueLch.h - asLch.h);

			// Wrap around the other side of the hue wheel
			if (hDifference > 180) hDifference = 360 - hDifference;

			// When either is sufficiently small, the other doesn't matter
			const score = cDifference * (hDifference ** 3);

			if (score < winningDifference) {
				return [score, shade];
			}

			return [winningDifference, winningShade];
		}, [Number.POSITIVE_INFINITY, "unknown"])]));

	// @ts-ignore
	// eslint-disable-next-line max-len
	const [, bestPalette] = differences.reduce(([winningScore, winningPalette], palettes, paletteIndex) => {
		// @ts-ignore
		// eslint-disable-next-line max-len
		const [lowestPaletteScore, lowestPaletteName] = palettes.reduce(([winningPaletteScore, winningPaletteName]: [number, string], [paletteName, [difference, _shade]]: [string, [number, string]]): [number, string] => {
			if (difference < winningPaletteScore) {
				return [difference, paletteName];
			}
			return [winningPaletteScore, winningPaletteName];
		}, [Number.POSITIVE_INFINITY, "unknown"]);

		// @ts-ignore
		if (lowestPaletteScore < winningScore) {
			// @ts-ignore
			// eslint-disable-next-line max-len
			return [lowestPaletteScore, paletteGroups[Object.keys(paletteGroups)[paletteIndex]][lowestPaletteName]];
		}
		return [winningScore, winningPalette];
	}, [Number.POSITIVE_INFINITY, defaultTailwindColors.gray]);

	return bestPalette;
};

export const accessibleColor = (color: string): string => (lch(color).l > 57 ? "#000000" : "#FFFFFF");

export const copyL = (input: string, source: string): string => {
	const inputColor = lch(input);
	inputColor.l = lch(source).l;
	return inputColor.formatHex();
};
export const copyC = (input: string, source: string): string => {
	const inputColor = lch(input);
	inputColor.c = lch(source).c;
	return inputColor.formatHex();
};
export const copyH = (input: string, source: string): string => {
	const inputColor = lch(input);
	inputColor.h = lch(source).h;
	return inputColor.formatHex();
};

export const generateOutputPalette = (input: string, source: Palette): { nearestShade: string, palette: Palette, sourceWithIntermediate: Palette } => {
	const sourceEntries = Object.entries(source);
	const white: [string, string] = ["0", "#ffffff"];
	const black: [string, string] = ["1000", "#000000"];
	sourceEntries.unshift(white);
	sourceEntries.push(black);

	const inputColor = lch(input);

	// eslint-disable-next-line @typescript-eslint/no-unused-vars
	const isLighter = ([_shade, value]: [string, string]) => lch(value).l > inputColor.l;
	const lighterShades = sourceEntries.filter(isLighter);
	const darkerShades = sourceEntries.filter((entry) => !isLighter(entry));
	const lighterByOne = lighterShades[lighterShades.length - 1] ?? white;
	const darkerByOne = darkerShades[0] ?? black;

	const shadePairs = zip(sourceEntries, tail(sourceEntries)).slice(0, -1);
	// @ts-ignore -- just too complicated to make correct manually
	// eslint-disable-next-line max-len
	const transformations = shadePairs.map(([[lighterShade, lighterValue], [darkerShade, darkerValue]]) => {
		const shadeDifference = parseInt(darkerShade, 10) - parseInt(lighterShade, 10);
		const [lighterColor, darkerColor] = [lch(lighterValue), lch(darkerValue)];

		const lDifference = lighterColor.l - darkerColor.l;
		const cDifference = (lighterColor.c || 0) - (darkerColor.c || 0);
		let hDifference = (lighterColor.h || 0) - (darkerColor.h || 0);
		// Wrap around the other side of the hue wheel
		if (hDifference > 180) hDifference = 360 - hDifference;
		else if (hDifference <= -180) hDifference = 360 + hDifference;

		return {
			shade: {
				from: lighterShade,
				to: darkerShade,
				difference: shadeDifference,
			},
			value: {
				from: lighterValue,
				to: darkerValue,
				lDifference,
				cDifference,
				hDifference,
			},
		};
	});

	// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	const [lighterShade, lighterValue] = [parseInt(lighterByOne![0], 10), lch(lighterByOne![1])];
	// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	const [darkerShade, darkerValue] = [parseInt(darkerByOne![0], 10), lch(darkerByOne![1])];

	const shadeRange = darkerShade - lighterShade;
	const luminanceRange = lighterValue.l - darkerValue.l;
	const shadeDarker = (shadeRange / luminanceRange) * (lighterValue.l - inputColor.l);

	const intermediacy = shadeDarker / shadeRange;
	// Find out what shade this input color corresponds to (e.x. 465.5474821)
	const intermediateShade = lighterShade + shadeDarker;



	const output: Record<string, ReturnType<typeof lch>> = { };
	// Generate the next shade up (lighter) that's a multiple of 100
	const lighterEquivalentC = inputColor.c + (lighterValue.c - darkerValue.c) * (intermediacy);
	const lighterEquivalentH = inputColor.h + (lighterValue.h - darkerValue.h) * (intermediacy);
	output[lighterShade] = lchClamped(lighterValue.l, lighterEquivalentC, lighterEquivalentH);
	
	// Generate the next shade down (darker) that's a multiple of 100
	const darkerEquivalentC = inputColor.c - (lighterValue.c - darkerValue.c) * (1 - intermediacy);
	const darkerEquivalentH = inputColor.h - (lighterValue.h - darkerValue.h) * (1 - intermediacy);
	output[darkerShade] = lchClamped(darkerValue.l, darkerEquivalentC, darkerEquivalentH);


	// Generate lighter shades
	forEachRight(lighterShades, ([newShade, _oldValue]) => {
		// eslint-disable-next-line max-len
		const [neededTransformation] = transformations.filter((transformation) => transformation.shade.from === newShade);
		if (neededTransformation === undefined) return;
		const newL = (output[neededTransformation.shade.to].l || 0) + neededTransformation.value.lDifference;
		const newC = (output[neededTransformation.shade.to].c || 0) + neededTransformation.value.cDifference;
		const newH = (output[neededTransformation.shade.to].h || 0) + neededTransformation.value.hDifference;
		output[newShade] = lchClamped(newL, newC, newH);
	});

	// Add this shade between the lighter generated ones and the darker generated ones
	const nearestShade = Math.round(intermediateShade).toString();
	output[nearestShade] = inputColor;

	// Generate darker shades
	forEach(darkerShades, ([newShade, _oldValue]) => {
		// eslint-disable-next-line max-len
		const [neededTransformation] = transformations.filter((transformation) => transformation.shade.to === newShade);
		if (neededTransformation === undefined) return;
		const newL = (output[neededTransformation.shade.from].l || 0) - neededTransformation.value.lDifference;
		const newC = (output[neededTransformation.shade.from].c || 0) - neededTransformation.value.cDifference;
		const newH = (output[neededTransformation.shade.from].h || 0) - neededTransformation.value.hDifference;
		output[newShade] = lchClamped(newL, newC, newH);
	});

	// Chop off the white and black shades at the beginning and end
	// eslint-disable-next-line max-len
	const outputHex = Object.fromEntries(Object.entries(output).map(([shade, color]) => [shade, color.formatHex()]).slice(1, -1));

	const sourceWithIntermediate = { ...source };

	const isLighterThanIntermediate = ([shade, _value]: [string, string]) => parseInt(shade, 10) < intermediateShade;
	const lighterSourceShades = sourceEntries.filter(isLighterThanIntermediate);
	const darkerSourceShades = sourceEntries.filter((entry) => !isLighterThanIntermediate(entry));
	const lighterSourceByOne = lighterShades[lighterShades.length - 1] ?? white;
	const darkerSourceByOne = darkerShades[darkerShades.length - 1] ?? black;

	const sourceIntermediate = intermediateShade;

	// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	const [lighterSourceShade, lighterSourceValue] = [parseInt(lighterByOne![0], 10), lch(lighterByOne![1])];
	// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	const [darkerSourceShade, darkerSourceValue] = [parseInt(darkerByOne![0], 10), lch(darkerByOne![1])];

	const shadeSourceRange = darkerSourceShade - lighterSourceShade;
	const shadeSourceDarker = lighterSourceShade - intermediateShade;
	const luminanceSourceRange = lighterSourceValue.l - darkerSourceValue.l;
	const chromaSourceRange = lighterSourceValue.c - darkerSourceValue.c;
	const hueSourceRange = lighterSourceValue.h - darkerSourceValue.h;

	const sourceIntermediacy = shadeSourceDarker / shadeSourceRange;

	const intermediateSourceL = luminanceSourceRange * sourceIntermediacy + lighterSourceValue.l;
	const intermediateSourceC = chromaSourceRange * sourceIntermediacy + lighterSourceValue.c;
	const intermediateSourceH = hueSourceRange * sourceIntermediacy + lighterSourceValue.h;

	const intermediateSourceValue = lchClamped(intermediateSourceL, intermediateSourceC, intermediateSourceH);
	sourceWithIntermediate[nearestShade] = intermediateSourceValue.formatHex();

	return {
		sourceWithIntermediate,
		nearestShade,
		palette: outputHex,
	}
};
